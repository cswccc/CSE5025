# 充电桩覆盖收益最大化问题

## 第一章 问题背景与描述

### 1.1 问题场景

考虑如下的组合优化问题。设有一座城市，共有若干居民楼，总数记为 $n \in \mathbb{Z}_+$，楼栋索引集合为 $\mathcal{I} = \{1,2,\dots,n\}$。对于每一栋楼 $i \in \mathcal{I}$，已知其潜在需要使用电动车充电桩的总人数为 $D_i \ge 0$，且每覆盖其中一名用户即可带来单位收益 $p_i \ge 0$，该收益因楼而异。规划部门预先给出了 $m$ 个可选的充电桩区域，区域索引集合为 $\mathcal{J} = \{1,2,\dots,m\}$。每个区域 $j \in \mathcal{J}$ 所能服务的楼栋集合是给定的，用覆盖关系矩阵 $a_{ij} \in \{0, 1\}$ 表示，不同区域之间的覆盖范围可以重叠，即可能存在某些楼栋同时属于多个区域的覆盖范围。若选择建设区域 $j$，则需要支付一笔固定建设成本 $c_j \ge 0$，该成本可包含土建、配电、设备安装及相关手续费用等。在区域 $j$ 内可以设置若干个充电桩，设其数量为 $x_j$，但受物理条件、规划或容量约束，每个区域可设置的充电桩数量存在上限 $U_j \in \mathbb{Z}_+$，超过这一上限在实际规划中不可行。为简化模型，假定每个充电桩可以服务一个"单位用户"（或认为每个桩的服务能力已折算为统一的用户单位），从而区域 $j$ 实际可服务的用户总数上界为 $x_j$。

我们的目标是在预算和容量约束条件下，决定哪些区域需要建设以及在每个已建设区域中设置多少个充电桩，并在覆盖关系限制下将各楼栋的用户分配到相应区域，使"覆盖用户带来的总收益减去建设成本"的净收益最大化。

---

## 第二章 数学建模

### 2.1 参数定义

**集合与索引：**
- $\mathcal{I} = \{1,2,\dots,n\}$：楼栋索引集合，$n$ 为楼栋总数
- $\mathcal{J} = \{1,2,\dots,m\}$：区域索引集合，$m$ 为候选区域总数

**输入参数：**
- $D_i \ge 0$：楼栋 $i$ 的潜在用户总数
- $p_i \ge 0$：楼栋 $i$ 每覆盖一个用户带来的收益
- $c_j \ge 0$：区域 $j$ 的固定建设成本
- $U_j \in \mathbb{Z}_+$：区域 $j$ 的充电桩数量上限
- $a_{ij} \in \{0,1\}$：覆盖关系矩阵，$a_{ij} = 1$ 表示区域 $j$ 可以覆盖楼栋 $i$

### 2.2 决策变量

为刻画这一决策过程，引入如下决策变量：

**1. 建设决策变量**

对每个区域 $j \in \mathcal{J}$ 定义 0–1 决策变量

$$
z_j =
\begin{cases}
1, & \text{若在区域 } j \text{ 建设充电桩区域},\\
0, & \text{否则}。
\end{cases}
$$

变量 $z_j$ 表示是否选择在区域 $j$ 进行建设。

**2. 充电桩配置变量**

用变量 $x_j$ 表示在区域 $j$ 内设置的充电桩数量。为了反映桩数的离散性，规定 $x_j \in \mathbb{Z}_+$。

**3. 用户分配变量**

用变量 $y_{ij}$ 表示楼栋 $i$ 中被分配到区域 $j$ 进行充电的用户人数，对所有楼栋–区域对 $(i,j)$ 规定 $y_{ij} \ge 0$。

### 2.3 约束条件

**1. 覆盖与建设逻辑约束**

由于只有在区域 $j$ 能够覆盖楼栋 $i$ 且该区域被建设的情况下，才允许将楼栋 $i$ 的用户分配到区域 $j$，因此可以通过如下约束刻画这一逻辑关系：

$$
y_{ij} \le D_i\, a_{ij}\, z_j,\quad \forall i \in \mathcal{I},\ \forall j \in \mathcal{J}.
$$

当 $a_{ij} = 0$ 或 $z_j = 0$ 时，上述约束强制 $y_{ij} = 0$，从而禁止在未覆盖或未建设的区域中为该楼栋分配用户。

**2. 用户需求约束**

每栋楼的用户总数不能被超额分配，即对每个 $i \in \mathcal{I}$ 有

$$
\sum_{j \in \mathcal{J}} y_{ij} \le D_i,
$$

这表示来自楼栋 $i$ 的所有分配人数总和不得超过其潜在需求 $D_i$。

**3. 区域容量约束**

区域 $j$ 的服务能力受到其内部充电桩数量的限制。由于假定每个桩可服务一个单位用户，因此区域 $j$ 能服务的用户总数上界为 $x_j$，从而对每个 $j \in \mathcal{J}$ 有容量约束

$$
\sum_{i \in \mathcal{I}} y_{ij} \le x_j.
$$

**4. 充电桩数量联动约束**

充电桩数量又受到区域上限的控制，并且只有在区域被建设时才允许设置充电桩，为此对每个 $j \in \mathcal{J}$ 引入联动约束

$$
0 \le x_j \le U_j\, z_j.
$$

当 $z_j = 0$ 时，该约束强制 $x_j = 0$，表示未建设的区域不能配置充电桩；当 $z_j = 1$ 时则允许 $x_j$ 在区间 $[0, U_j]$ 内取值。

**5. 变量类型约束**

$$
z_j \in \{0,1\},\quad x_j \ge 0,\quad y_{ij} \ge 0,\quad \forall i \in \mathcal{I},\ \forall j \in \mathcal{J}.
$$

### 2.4 目标函数

**1. 总收益计算**

所有被成功覆盖的用户带来的总收益可以表示为

$$
\sum_{i \in \mathcal{I}} \sum_{j \in \mathcal{J}} p_i\, y_{ij}.
$$

**2. 总成本计算**

为建设各个区域支付的总固定成本为

$$
\sum_{j \in \mathcal{J}} c_j\, z_j.
$$

**3. 净收益目标函数**

我们希望最大化的净收益（即总收益减去总成本）为

$$
\sum_{i \in \mathcal{I}} \sum_{j \in \mathcal{J}} p_i\, y_{ij} \;-\; \sum_{j \in \mathcal{J}} c_j\, z_j.
$$

### 2.5 完整数学规划模型

将上述目标函数与约束条件综合起来，可以得到该充电桩选址与配置问题的形式化数学规划模型：

$$
\begin{aligned}
\max_{z,x,y}\quad & \sum_{i \in \mathcal{I}} \sum_{j \in \mathcal{J}} p_i\, y_{ij} \;-\; \sum_{j \in \mathcal{J}} c_j\, z_j,\\
\text{s.t.}\quad 
& y_{ij} \le D_i\, a_{ij}\, z_j,\quad && \forall i \in \mathcal{I},\ \forall j \in \mathcal{J},\\[4pt]
& \sum_{j \in \mathcal{J}} y_{ij} \le D_i,\quad && \forall i \in \mathcal{I},\\[4pt]
& \sum_{i \in \mathcal{I}} y_{ij} \le x_j,\quad && \forall j \in \mathcal{J},\\[4pt]
& 0 \le x_j \le U_j\, z_j,\quad && \forall j \in \mathcal{J},\\[4pt]
& z_j \in \{0,1\},\ x_j \ge 0,\ y_{ij} \ge 0,\quad && \forall i \in \mathcal{I},\ \forall j \in \mathcal{J}.
\end{aligned}
$$

该模型刻画了在存在覆盖重叠、建设成本以及容量上限等现实约束条件下，如何选择建设哪些充电区域并配置相应数量的充电桩，以及如何将不同楼栋的用户分配到各个区域，从而最大化总体经济收益的组合优化问题，本质上属于一个**混合整数线性规划**模型。

---

## 第三章 复杂度分析与规约证明

### 3.1 判定问题的形式化

在前面给出的数学模型基础上，下面从计算复杂度的角度，对该充电桩选址与配置问题进行形式化分析，给出其判定版本属于 NP，并通过从集合覆盖（Set Cover）问题的多项式时间规约证明该问题是 NP-hard，从而其判定版本为 NP-complete，优化版本为 NP-hard。

我们先将原始的**优化问题**改写为一个**判定问题**。给定参数
- 楼栋集合 $\mathcal{I} = \{1,\dots,n\}$，区域集合 $\mathcal{J} = \{1,\dots,m\}$；
- 潜在需求 $D_i \ge 0$，单位收益 $p_i \ge 0$；
- 区域固定成本 $c_j \ge 0$，最大桩数上限 $U_j \in \mathbb{Z}_+$；
- 覆盖关系矩阵 $a_{ij} \in \{0,1\}$；
- 以及目标阈值 $K \in \mathbb{R}$，

考虑如下判定问题：

> **充电桩选址判定问题**：是否存在一组决策变量 $(z,x,y)$ 满足所有约束  
> $$
> \begin{aligned}
> & y_{ij} \le D_i a_{ij} z_j,\quad && \forall i\in\mathcal{I},\ \forall j\in\mathcal{J},\\
> & \sum_{j\in\mathcal{J}} y_{ij} \le D_i,\quad && \forall i\in\mathcal{I},\\
> & \sum_{i\in\mathcal{I}} y_{ij} \le x_j,\quad && \forall j\in\mathcal{J},\\
> & 0 \le x_j \le U_j z_j,\quad && \forall j\in\mathcal{J},\\
> & z_j\in\{0,1\},\ x_j\ge 0,\ y_{ij}\ge 0,\quad && \forall i\in\mathcal{I},\ \forall j\in\mathcal{J},
> \end{aligned}
> $$
> 且目标函数满足
> $$
> \sum_{i\in\mathcal{I}}\sum_{j\in\mathcal{J}} p_i\, y_{ij} - \sum_{j\in\mathcal{J}} c_j\, z_j \;\ge K\ ?
> $$

### 3.2 判定问题属于 NP

给定一个候选解 $(z,x,y)$，我们可以在多项式时间内验证它是否为一个"证据"（certificate）：

**1. 检查线性约束**

对每个 $(i,j)$ 检查  
$y_{ij} \le D_i a_{ij} z_j$，  
对每个 $i$ 检查 $\sum_{j} y_{ij} \le D_i$，  
对每个 $j$ 检查 $\sum_{i} y_{ij} \le x_j$ 和 $0 \le x_j \le U_j z_j$。  
这些都是有限个线性不等式，个数为 $\mathcal{O}(nm+n+m)$，逐一计算和比较的时间是多项式的。

**2. 检查变量类型**

对每个 $j$ 检查 $z_j\in\{0,1\}$，对每个 $j$ 检查 $x_j\ge 0$，对每个 $(i,j)$ 检查 $y_{ij}\ge 0$，不等式个数为$\mathcal{O}(nm)$，计算时间也是多项式的。

**3. 计算目标函数并比较阈值**

在 $\mathcal{O}(nm + m)$ 时间内计算
$$
\sum_{i\in\mathcal{I}}\sum_{j\in\mathcal{J}} p_i\, y_{ij} - \sum_{j\in\mathcal{J}} c_j\, z_j
$$
并与给定阈值 $K$ 做一次比较即可。

假设所有输入参数（包括 $D_i,p_i,c_j,U_j,a_{ij},K$ 等）都以二进制编码给出，则上述检验步骤的时间复杂度为输入规模的多项式。因此，该判定问题属于类 $\mathrm{NP}$：一旦给出一个候选解，就可以在多项式时间内验证其可行性以及目标值是否达到阈值 $K$。

### 3.3 从 Set Cover 的规约

为了证明该问题是 NP-hard，我们从经典的集合覆盖问题（Set Cover）构造一个多项式时间规约。

#### 3.3.1 集合覆盖问题回顾

集合覆盖判定问题定义如下：

- 给定一个有限集合（宇宙）  
  $$
  U = \{e_1,e_2,\dots,e_n\},
  $$
- 一族子集  
  $$
  \mathcal{S} = \{S_1,S_2,\dots,S_m\},\quad S_j \subseteq U,
  $$
- 以及一个正整数 $k$，

问：是否存在一个索引集合 $J^\star \subseteq \{1,\dots,m\}$，满足 $|J^\star| \le k$ 且
$$
\bigcup_{j\in J^\star} S_j = U\ ?
$$

该问题是著名的 NP-complete 问题。我们将证明：对任意一个 Set Cover 实例 $(U,\mathcal{S},k)$，都可以在多项式时间内构造一个充电桩选址判定实例，使得前者存在规模不超过 $k$ 的覆盖当且仅当后者存在一个目标值不小于某一阈值 $K$ 的可行解。

#### 3.3.2 规约构造步骤

给定 Set Cover 实例 $(U,\mathcal{S},k)$，其中
$$
U = \{e_1,\dots,e_n\},\quad
\mathcal{S} = \{S_1,\dots,S_m\},
$$
我们按如下方式构造一个充电桩选址实例。

**步骤 1：楼栋与元素对应**

将每个元素 $e_i\in U$ 对应为一栋楼 $i$。于是楼栋集合为
$$
\mathcal{I} = \{1,\dots,n\},\quad n = |U|.
$$
对每栋楼 $i$ 设置潜在需求
$$
D_i = 1,\quad \forall i\in\mathcal{I},
$$
即每个元素只需要"被服务"一次。为简化，将每个被覆盖用户的收益设置为统一常数：
$$
p_i = M,\quad \forall i\in\mathcal{I},
$$
其中常数 $M$ 取为
$$
M = m + 1.
$$

**步骤 2：区域与子集对应**

将每个子集 $S_j$ 对应为一个候选区域 $j$。于是区域集合为
$$
\mathcal{J} = \{1,\dots,m\},\quad m = |\mathcal{S}|.
$$
定义覆盖关系矩阵 $a_{ij}$ 为
$$
a_{ij} =
\begin{cases}
1, & \text{若 } e_i \in S_j,\\
0, & \text{否则},
\end{cases}
\qquad \forall i\in\mathcal{I},\ \forall j\in\mathcal{J},
$$
即区域 $j$ 正好覆盖集合 $S_j$ 对应的那些楼栋。

**步骤 3：容量与建设成本**

为避免容量约束人为限制，令每个区域的最大桩数上限足够大，例如
$$
U_j = n,\quad \forall j\in\mathcal{J},
$$
并允许 $x_j$ 足以服务所有其覆盖的楼栋（因为每栋最多 1 个用户）。区域建设成本设为常数
$$
c_j = 1,\quad \forall j\in\mathcal{J},
$$
即每选一个区域的成本为 1。在容量足够大的情况下，只要 $z_j = 1$，就完全可以为该区域能覆盖到的楼栋提供服务。

**步骤 4：阈值设定**

在该充电问题上，我们关注如下目标函数：
$$
\text{Profit}(z,x,y) = 
\sum_{i\in\mathcal{I}}\sum_{j\in\mathcal{J}} p_i\, y_{ij} - \sum_{j\in\mathcal{J}} c_j\, z_j.
$$

在上述构造下，由于 $D_i = 1$，每个楼栋 $i$ 要么完全被某个区域服务（贡献 $M$ 的收益），要么完全未被服务（贡献 $0$）。记被成功覆盖的楼栋集合为
$$
C(J) = \{i\in\mathcal{I} : \text{存在 } j\in\mathcal{J} \text{ 使 } y_{ij} = 1\},
$$
记被选择的区域集合为
$$
J = \{j\in\mathcal{J}: z_j = 1\}.
$$

此时可以将目标函数重写为
$$
\text{Profit}(J) = M\cdot |C(J)| - |J|.
$$

我们在规约中选择阈值
$$
K = M n - k.
$$

**步骤 5：构造规模与时间**

从 $(U,\mathcal{S},k)$ 构造上述参数 $D_i,p_i,c_j,U_j,a_{ij},K$ 的过程，只需要遍历所有元素和子集，计算 $a_{ij}$，其时间复杂度为多项式（约为 $\mathcal{O}(nm)$），因此该规约是多项式时间的。

### 3.4 规约正确性证明

我们证明如下的等价性命题：

> **命题**：原 Set Cover 实例存在一个大小不超过 $k$ 的集合覆盖  
> 当且仅当  
> 构造的充电选址实例存在一个可行解使  
> $$
> \text{Profit}(z,x,y) \ge K = M n - k.
> $$

#### 3.4.1 充分性证明

**如果存在集合覆盖，则存在利润至少为 $K$ 的解**

假设在 Set Cover 实例中，存在一个索引集合 $J^\star \subseteq \{1,\dots,m\}$，满足
$$
|J^\star| \le k,\quad \bigcup_{j\in J^\star} S_j = U.
$$

在充电实例中构造如下解：

- 对 $j\in J^\star$，令 $z_j = 1$；对 $j\notin J^\star$，令 $z_j = 0$；
- 对每个选择的区域 $j\in J^\star$，取足够多的桩数（例如 $x_j = n$），显然满足 $x_j \le U_j z_j$；
- 由于 $J^\star$ 是集合覆盖，对每个楼栋 $i$，至少存在某个 $j\in J^\star$ 使 $a_{ij} = 1$。从中任取一个区域 $j$，令 $y_{ij} = 1$，其余 $y_{ij'} = 0$。这样对所有楼栋 $i$ 都有 $\sum_{j} y_{ij} = 1 \le D_i$，并且对每个区域 $j$ 有
  $$
  \sum_{i} y_{ij} \le n = x_j,
  $$
  所有约束均被满足。

此时所有楼栋都被覆盖，即 $C(J^\star) = \mathcal{I}$，从而 $|C(J^\star)| = n$。目标函数为
$$
\text{Profit}(J^\star) = M n - |J^\star|
\ge M n - k = K.
$$

因此，若 Set Cover 实例有大小不超过 $k$ 的覆盖，则充电实例中存在一个可行解使目标值至少为 $K$。

#### 3.4.2 必要性证明

**如果存在利润至少为 $K$ 的解，则存在大小不超过 $k$ 的集合覆盖**

反方向，假设在充电实例中存在一个可行解 $(z,x,y)$，对应的区域集合
$$
J = \{j\in\mathcal{J} : z_j = 1\},
$$
满足
$$
\text{Profit}(J) = M |C(J)| - |J| \ge K = M n - k.
$$

首先证明该解必须覆盖所有楼栋，即 $|C(J)| = n$。

若存在某个楼栋 $i$ 未被服务，则 $i\notin C(J)$，因此 $|C(J)| \le n-1$。注意 $|J|\ge 0$，故有
$$
\text{Profit}(J) = M|C(J)| - |J|
\le M (n-1) - 0 = M(n-1).
$$

而
$$
K = M n - k \ge M n - m.
$$

代入 $M = m + 1$，得到
$$
M n - m = (m+1)n - m = (m+1)(n-1) + (m+1 - m)
= M (n-1) + 1.
$$

于是
$$
K \ge M(n-1) + 1 > M(n-1).
$$

这与 $\text{Profit}(J) \le M(n-1)$ 和 $\text{Profit}(J) \ge K$ 矛盾。因此，任何满足 $\text{Profit}(J)\ge K$ 的可行解必须满足 $|C(J)| = n$，即所有楼栋都被覆盖。

在 $|C(J)| = n$ 的情况下，目标函数化简为
$$
\text{Profit}(J) = M n - |J|.
$$

条件 $\text{Profit}(J)\ge K = M n - k$ 等价于
$$
M n - |J| \ge M n - k
\quad\Longleftrightarrow\quad
|J| \le k.
$$

由于 $|C(J)| = n$，说明对每个楼栋 $i$ 都存在 $j\in J$ 使 $a_{ij}=1$，也即
$$
\{e_i : i\in\mathcal{I}\} \subseteq \bigcup_{j\in J} S_j.
$$

由构造中楼栋与元素一一对应可知
$$
\bigcup_{j\in J} S_j = U,
$$
且 $|J|\le k$。这说明集合 $J$ 在原 Set Cover 实例中给出了一个大小不超过 $k$ 的集合覆盖。

综上，如果在充电实例中存在利润不小于 $K$ 的可行解，则相应地在 Set Cover 实例中存在一个规模不超过 $k$ 的集合覆盖。

### 3.5 复杂度结论

上述构造在输入规模的多项式时间内完成，并且满足
- Set Cover 实例为 "Yes" 当且仅当
- 对应的充电选址判定实例为 "Yes"（存在解使目标值 $\ge K$）。

因此，我们得到从 Set Cover 判定问题到充电桩选址判定问题的多项式时间规约。由于 Set Cover 判定问题是 NP-complete，且我们的充电判定问题已证明属于 NP，由此可知：

- **充电桩选址判定问题是 NP-complete**；
- **相应的优化问题（最大化利润）是 NP-hard**。

这意味着在一般情况下，除非 $\mathrm{P} = \mathrm{NP}$，不存在多项式时间算法可以求得该优化问题的全局最优解；该问题在复杂度意义上属于典型的组合优化难题。


## 第四章 算法设计

### 4.0 统一的最优分配策略

所有求解算法都采用以下统一的子问题求解策略：

**核心思想**：一旦选址决策 $z$ 确定，充电桩数量 $x$ 直接设置为容量上限（$x_j = U_j \cdot z_j$），然后使用**最小费用最大流算法**精确求解最优的用户分配 $y$。

**理论依据**：
- 由于增加充电桩不会带来额外的边际成本（只有固定的建设成本 $c_j$），因此对于选中的区域，将充电桩数量设置为上限总是最优的
- 固定 $z$ 和 $x$ 后，用户分配子问题可以建模为最小费用最大流问题，可在多项式时间内精确求解

**最小费用最大流建模**（详见用户提供的建模文档）：
- 网络结构：源点 $s$ → 楼栋节点 $i$ → 区域节点 $j$ → 汇点 $t$，以及楼栋直接到汇点的边
- 边容量：源点到楼栋 $D_i$，楼栋到区域 $D_i$（当 $a_{ij}=1$ 且 $z_j=1$），区域到汇点 $U_j \cdot z_j$
- 边费用：楼栋到区域的边费用为 $-p_i$（最小化费用等价于最大化收益）
- 复杂度：$O((n+m)^2 \times \log(n+m) \times C)$，其中 $C$ 是最大容量

---

### 4.1 暴力枚举（Brute-force）

#### 4.1.1 算法思路  
1. **外层枚举**：枚举所有 $2^m$ 种建设方案 $z \in \{0,1\}^m$
2. **子问题求解**：对每种方案 $z$：
   - 设置充电桩数量：$x_j = U_j \cdot z_j$（直接装满）
   - 使用**最小费用最大流算法**精确求解最优的用户分配 $y$
   - 计算目标函数值：$\sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$
3. **选择最优解**：记录使目标值最大的 $(z,x,y)$
4. 返回全局最优解

#### 4.1.2 复杂度分析

**时间复杂度**：
- 枚举次数：$2^m$
- 单次最小费用最大流：$O((n+m)^2 \times \log(n+m) \times C)$，其中 $C = \max\{D_i, U_j\}$
- **总体时间复杂度**：$O(2^m \times (n+m)^2 \times \log(n+m) \times C)$

**空间复杂度**：
- 存储当前最优解：$O(n \times m)$（用于存储 $y$ 矩阵）
- 最小费用最大流算法：$O(n+m)$ 个节点，$O(n \times m)$ 条边
- **总体空间复杂度**：$O(n \times m)$

**适用规模**：$m \leq 15$ 时算法尚可接受，$m > 20$ 时基本不可行（指数爆炸）

#### 4.1.3 近似比  
暴力枚举给出全局最优解，近似比 $\rho = 1$，无近似误差。

#### 4.1.4 实现细节

- 支持时间限制（`time_limit` 参数），超时后返回当前找到的最优解
- 对于 $m > 15$ 的情况，仅枚举前1000种方案以避免计算时间过长
- 使用 `itertools.product` 高效生成所有 $(0,1)$ 组合  

---

### 4.2 贪心构造（Greedy Construction）

#### 4.2.1 算法思路  

**阶段 A：构造**  
1. 初始化：所有 $z_j=0$，$x_j=0$，$y_{ij}=0$
2. 计算每个候选区域 $j$ 的「性价比」：
   - 潜在收益：$\text{region\_profits}_j = \bar{p}_j \times \min\{\sum_{i:a_{ij}=1} D_i, U_j\}$，其中 $\bar{p}_j$ 是区域 $j$ 覆盖楼栋的平均单位收益
   - 性价比：$\text{score}_j = \frac{\text{region\_profits}_j}{c_j}$
3. 按性价比从高到低排序区域
4. 依次尝试添加每个区域 $j$：
   - 设置 $z_j=1$，$x_j=U_j$
   - 使用**最小费用最大流算法**计算最优分配 $y$ 和目标函数值
   - 如果目标函数提升，则保留该区域；否则撤销
5. 对最终选中的区域集合，再次使用最小费用最大流算法进行最优分配

**注意**：与传统的贪心分配不同，本实现使用最小费用最大流算法进行用户分配，确保在给定选址下获得最优的用户分配。

#### 4.2.2 复杂度分析

**时间复杂度**：
- 计算性价比：$O(n \times m)$
- 排序：$O(m \log m)$
- 贪心选择：最多 $m$ 次迭代，每次调用最小费用最大流算法
- **总体时间复杂度**：$O(m \times (n+m)^2 \times \log(n+m) \times C)$

**空间复杂度**：
- 存储当前解：$O(n \times m)$
- 最小费用最大流算法：$O(n \times m)$
- **总体空间复杂度**：$O(n \times m)$

#### 4.2.3 近似比分析  
本问题可视为"带基数惩罚的覆盖+背包"混合问题。沿用 Set-Cover 贪心结论，理论上：
- $\rho \leq H_n + 1$，其中 $H_n = 1 + 1/2 + \ldots + 1/n \approx \ln n$ 是第 $n$ 个调和数
- 若所有 $p_i=1$，退化为带惩罚的集合覆盖，$\rho \leq H_n$
- 一般收益异构时，$\rho \leq H_n \cdot (p_{\max}/p_{\min})$

**实际性能**：由于使用了最小费用最大流进行用户分配，实际性能通常优于传统贪心方法，实验显示实际近似比 $\rho \approx 1.1 \sim 1.3$。

#### 4.2.4 优缺点

**优点**：
- 运行速度快，适合大规模问题
- 实现简单，易于理解和调试
- 使用最小费用最大流确保用户分配的最优性

**缺点**：
- 不能保证全局最优（选址策略是贪心的）
- 可能陷入局部最优  

---

### 4.3 基于 MILP 的精确算法

#### 4.3.1 算法思路  
1. 将第二章的数学模型直接建模为混合整数线性规划（MILP）：
   - 决策变量：$z_j \in \{0,1\}$（二进制），$x_j \in \mathbb{Z}_+$（整数），$y_{ij} \in \mathbb{Z}_+$（整数）
   - 目标函数：$\max \sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$
   - 约束条件：覆盖关系、需求约束、容量约束、以及关键约束 $x_j = U_j \cdot z_j$
2. 使用 PuLP 库调用 CBC 求解器（或其他 MILP 求解器）进行分支定界求解
3. 提取并返回最优解

#### 4.3.2 复杂度分析

**时间复杂度**：
- 变量数：$m$（$z$）+ $m$（$x$）+ $n \times m$（$y$）= $O(n \times m)$
- 约束数：$O(n \times m)$（覆盖关系）+ $n$（需求）+ $m$（容量）+ $m$（容量上限）= $O(n \times m)$
- 分支定界最坏情况节点数：$O(2^m)$（考虑 $z$ 变量的分支）
- 单节点 LP 松弛：$O((n \times m)^{3.5})$（内点法 worst-case）
- **总体时间复杂度**：指数级，最坏情况 $O(2^m \times (n \times m)^{3.5})$，实际中由于剪枝和预处理通常远小于此

**空间复杂度**：
- 存储 MILP 模型：$O(n \times m)$（约束矩阵）
- 分支定界树：最坏情况 $O(2^m)$ 个节点
- **总体空间复杂度**：$O(n \times m + 2^m)$，实际中由于剪枝通常远小于 $2^m$

**适用规模**：中等规模问题（$m \leq 30$，$n \leq 50$），具体取决于求解器性能

#### 4.3.3 近似比  
MILP 求解器返回最优解时，近似比 $\rho = 1$（全局最优）。若因时间限制提前停止，则给出当前最好的可行解和最优界（gap）。

#### 4.3.4 实现细节

- 使用 PuLP 库进行建模，底层调用 CBC 求解器（开源）
- 支持切换到其他求解器（如 Gurobi、CPLEX）以获得更好的性能
- 所有变量均为整数类型（$x$ 和 $y$ 不使用连续松弛）
- 关键约束 $x_j = U_j \cdot z_j$ 确保选址后充电桩直接装满  

---

### 4.4 遗传算法（Genetic Algorithm, GA）

#### 4.4.1 编码  
- **染色体表示**：二进制串 $\text{ch} \in \{0,1\}^m$，直接表示建设决策 $z$
- **解码过程**：对于给定的染色体 $z$：
  1. 设置充电桩数量：$x_j = U_j \cdot z_j$
  2. 使用**最小费用最大流算法**精确求解最优的用户分配 $y$
  3. 计算目标函数值：$\sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$

#### 4.4.2 适应度  
适应度函数直接使用目标函数值：
$$\text{fitness}(\text{ch}) = \sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$$

**注意**：由于使用最小费用最大流算法进行解码，每个个体都能得到给定 $z$ 下的最优 $y$，因此适应度计算是精确的。

#### 4.4.3 遗传算子  
- **初始化**：随机生成初始种群，每个个体以概率 0.3 为 1（偏向选择较少的区域）
- **选择**：轮盘赌选择（适应度比例选择），适应度高的个体被选中概率大
- **交叉**：单点交叉，交叉率 $p_c = 0.8$
- **变异**：位翻转，变异率 $p_m = 0.1$（通常设为 $1/m$）
- **精英保留**：每代保留最优的 10% 个体直接进入下一代

#### 4.4.4 参数与停止条件  
- 种群规模 $N = 50$（默认）
- 最大代数 $G = 100$（默认）
- **早停机制**：如果连续 `early_stop_patience = 20` 代没有改进，提前终止
- 其他参数：交叉率 0.8，变异率 0.1，精英比例 0.1

#### 4.4.5 复杂度分析

**时间复杂度**：
- 初始化：$O(N \times m)$
- 每代评估适应度：$N$ 次解码，每次调用最小费用最大流算法
- 选择、交叉、变异：$O(N \times m)$
- **总体时间复杂度**：$O(G \times N \times (n+m)^2 \times \log(n+m) \times C)$

**空间复杂度**：
- 存储种群：$O(N \times m)$
- 最小费用最大流算法：$O(n \times m)$
- **总体空间复杂度**：$O(N \times m + n \times m)$

#### 4.4.6 近似比与性能  
遗传算法作为元启发式算法，**无理论保证**，但在实践中表现良好：

- **与暴力枚举相比**：在 $m \leq 20$ 的问题上，通常能找到最优解或非常接近最优解（gap $\leq 1\%$）
- **与贪心算法相比**：平均提升 3~8%，特别是在大规模问题上优势明显
- **收敛性**：早停机制确保算法不会过度运行，通常 20-50 代即可收敛

#### 4.4.7 优缺点

**优点**：
- 可以跳出局部最优，适合大规模问题
- 使用最小费用最大流确保每种编码都能得到最优的用户分配
- 早停机制提高效率
- 参数可调，适应性强

**缺点**：
- 不能保证全局最优
- 参数需要调优
- 可能需要较多迭代次数  

---

### 4.5 最小费用最大流算法（用于子问题求解）

#### 4.5.1 问题背景  
所有求解算法都需要解决以下子问题：给定建设决策 $z$，如何最优分配用户 $y$？

**关键观察**：由于增加充电桩不会带来额外费用，最优策略是将充电桩数量设置为上限（$x_j = U_j \cdot z_j$）。因此，子问题简化为：给定 $z$ 和 $x = U \odot z$，如何最优分配用户 $y$？

#### 4.5.2 网络流建模  

将用户分配问题转化为最小费用最大流问题：

**网络结构**：
- **节点集合**：$\{s, t\} \cup \mathcal{I} \cup S$，其中 $S = \{j \in \mathcal{J} : z_j = 1\}$ 是已选中的区域集合
  - 源点 $s$
  - 楼栋节点 $i$（$n$ 个）
  - 区域节点 $j$（仅包括 $j \in S$）
  - 汇点 $t$

**有向边及其容量和费用**：
1. **源点到楼栋**：$s \to i$，容量 $D_i$，费用 $0$
2. **楼栋到区域**：$i \to j$（当 $a_{ij} = 1$ 且 $z_j = 1$ 时存在），容量 $D_i$，费用 $-p_i$
3. **区域到汇点**：$j \to t$（$j \in S$），容量 $U_j \cdot z_j = U_j$，费用 $0$
4. **楼栋直接到汇点**：$i \to t$，容量 $D_i$，费用 $0$（表示未被服务的用户）

**流量平衡**：
- 源点 $s$ 的供给：$\sum_i D_i$
- 汇点 $t$ 的需求：$\sum_i D_i$

#### 4.5.3 求解方法  

使用 NetworkX 库的 `max_flow_min_cost` 算法求解最小费用最大流，该算法基于 successive shortest path 或 cost scaling 方法。

**目标函数对应**：
- 网络流的总费用：$\text{Total Cost} = \sum_{i,j} (-p_i) \cdot y_{ij} = -\sum_{i,j} p_i y_{ij}$
- 最小化总费用等价于最大化总收益：$\max \sum_{i,j} p_i y_{ij} = -\min \text{Total Cost}$

#### 4.5.4 复杂度分析

**时间复杂度**：
- 网络节点数：$O(n + m)$（实际为 $n + |S| + 2$，其中 $|S| \leq m$）
- 网络边数：$O(n \times m)$（最坏情况每个楼栋都与每个区域相连）
- 最小费用最大流算法：$O((n+m)^2 \times \log(n+m) \times C)$，其中 $C = \max\{D_i, U_j\}$ 是最大容量
- **总体时间复杂度**：$O((n+m)^2 \times \log(n+m) \times C)$（多项式时间）

**空间复杂度**：
- 存储网络图：$O(n \times m)$（边的数量）
- 存储流结果：$O(n \times m)$
- **总体空间复杂度**：$O(n \times m)$

#### 4.5.5 整数性保证  

由于网络流问题的约束矩阵是全幺模（totally unimodular）矩阵，且所有容量均为整数，因此最小费用最大流算法会自动返回整数解，无需显式添加整数约束。这保证了 $y_{ij} \in \mathbb{Z}_+$，符合实际问题的离散性要求。

#### 4.5.6 最优性保证  

最小费用最大流算法保证找到最优解（给定 $z$ 和 $x$ 下的最优 $y$），这使得所有使用该方法的求解器都能在给定选址下获得最优的用户分配，确保了算法比较的公平性。  

---

### 4.6 关于动态规划

**注意**：由于该问题的约束条件复杂（覆盖关系、容量限制、多楼栋多区域），传统的动态规划方法难以直接应用。问题的状态空间太大（需要记录已覆盖的楼栋集合，状态数为 $2^n$），且不具有典型的递归最优子结构。因此本项目未实现动态规划方法。

如果问题规模很小且具有特定的结构，可以考虑使用状态压缩动态规划，但通用性较差。

---

### 4.7 算法总结与比较

| 算法 | 最优性保证 | 适用规模 | 时间复杂度 | 空间复杂度 | 主要优点 | 主要缺点 |
|------|-----------|----------|-----------|-----------|----------|----------|
| 暴力枚举 | ✓ 全局最优 | $m \leq 15$ | $O(2^m \times \text{MCF})$ | $O(n \times m)$ | 基准算法，结果可靠 | 指数爆炸，仅适用于小规模 |
| 贪心算法 | ✗ 理论 $H_n$ 近似 | 任意规模 | $O(m \times \text{MCF})$ | $O(n \times m)$ | 极速、易实现、使用最小费用最大流 | 可能陷入局部最优 |
| MILP | ✓ 全局最优 | 中等规模 ($m \leq 30$) | 指数级（分支定界） | $O(n \times m + 2^m)$ | 保证最优性，适用于中等规模 | 大规模问题求解时间过长 |
| 遗传算法 | ✗ 元启发式 | 大规模 ($m \leq 500$) | $O(G \times N \times \text{MCF})$ | $O(N \times m + n \times m)$ | 易并行、使用最小费用最大流、早停机制 | 参数敏感，无理论保证 |

其中：
- $\text{MCF} = O((n+m)^2 \times \log(n+m) \times C)$ 是最小费用最大流的复杂度（多项式时间）
- $G$ 是遗传算法的代数，$N$ 是种群大小
- $C = \max\{D_i, U_j\}$ 是最大容量

**关键设计特点**：
- 所有算法都采用统一的策略：选址后充电桩直接装满，然后使用最小费用最大流算法最优分配用户
- 这确保了所有方法都能在给定选址下获得最优的用户分配，算法比较更加公平
- 最小费用最大流算法提供了多项式时间的精确求解方法，相比传统的 LP 或贪心分配更加高效和准确

---

### 4.8 实验数据结果分析

本节基于实际测试数据（50个问题实例，涵盖5种不同规模：$n \in \{10,15,20,25,30\}$，$m \in \{5,8,10,12,15\}$）对四种算法的性能进行详细分析。

#### 4.8.1 最优解质量分析

**总体最优解概率统计**（跨所有50个实例）：

| 方法 | 得到最优解次数 | 最优解概率 | 说明 |
|------|--------------|-----------|------|
| MILP求解器 | 50/50 | **100%** | 在所有测试实例上都能找到最优解 |
| 遗传算法 | 48/50 | **96%** | 接近最优，仅2个实例未达到最优 |
| 暴力枚举 | 40/50 | **80%** | 小规模问题表现优秀，但$m=15$时完全失败 |
| 贪心算法 | 37/50 | **74%** | 约1/4的实例无法达到最优解 |

**按问题规模的最优解概率**：

- **小规模问题**（$n=10, m=5$）：
  - MILP、暴力枚举、遗传算法：**100%** 最优解概率
  - 贪心算法：**90%** 最优解概率
  
- **中等规模问题**（$n=15-25, m=8-12$）：
  - MILP、暴力枚举、遗传算法：**100%** 最优解概率
  - 贪心算法：**70%** 最优解概率（稳定在70%）
  
- **较大规模问题**（$n=30, m=15$）：
  - MILP求解器：**100%** 最优解概率（唯一保证最优的方法）
  - 遗传算法：**80%** 最优解概率
  - 贪心算法：**70%** 最优解概率
  - 暴力枚举：**0%** 最优解概率（达到时间限制，无法完成枚举）

**关键发现**：
1. **MILP求解器**在所有规模下都能保证100%找到最优解，证明了其作为精确算法的可靠性
2. **遗传算法**在小到中等规模问题上表现优异（100%），但在较大规模时略有下降（80%），总体96%的最优解概率说明其作为元启发式算法的有效性
3. **暴力枚举**在$m \leq 12$时表现完美，但$m=15$时因指数爆炸完全失效，验证了其适用规模的限制
4. **贪心算法**的最优解概率稳定在70-90%，说明其虽然快速但确实可能陷入局部最优

#### 4.8.2 运行时间性能分析

**总体运行时间统计**（跨所有50个实例）：

| 方法 | 平均时间 | 中位数时间 | 最小时间 | 最大时间 |
|------|---------|-----------|---------|---------|
| 贪心算法 | **30.7ms** | 24.2ms | 5.8ms | 99.3ms |
| MILP求解器 | 43.5ms | 24.2ms | 11.0ms | **327.4ms** |
| 暴力枚举 | 14.736s | 2.138s | 26.7ms | **1.00min** |
| 遗传算法 | 4.204s | 3.324s | 1.082s | 10.706s |

**按问题规模的运行时间趋势**：

- **小规模**（$n=10, m=5$）：
  - 贪心算法：平均15.8ms（最快）
  - MILP求解器：平均12.8ms（最快，但波动小）
  - 暴力枚举：平均32.6ms（可接受）
  - 遗传算法：平均1.221s（最慢，但仍在秒级）

- **中等规模**（$n=15-25, m=8-12$）：
  - 贪心算法：14-38ms（保持快速）
  - MILP求解器：21-46ms（时间增长但仍在毫秒级）
  - 暴力枚举：387ms-11.145s（时间急剧增长）
  - 遗传算法：2.3-5.8s（时间增长但稳定）

- **较大规模**（$n=30, m=15$）：
  - 贪心算法：61.4ms（仍然最快）
  - MILP求解器：92.2ms（中位数35.4ms，但最大327.4ms，波动大）
  - 暴力枚举：1.00min（达到时间限制）
  - 遗传算法：8.284s（时间较长但可接受）

**关键发现**：
1. **贪心算法**在所有规模下都是最快的，平均时间仅30.7ms，适合需要快速响应的场景
2. **MILP求解器**在大多数情况下运行时间很短（中位数24.2ms），但存在个别实例需要较长时间（最大327.4ms），说明分支定界算法的性能可能受问题结构影响
3. **暴力枚举**的时间随规模指数增长，$m=15$时达到1分钟时间限制，验证了其指数复杂度的理论分析
4. **遗传算法**的运行时间相对稳定，虽然较长（秒级），但在大规模问题上仍可接受

#### 4.8.3 各方法优缺点详细分析

##### 贪心算法

**优点**：
- ✅ **速度极快**：平均运行时间仅30.7ms，在所有方法中最快
- ✅ **实现简单**：算法逻辑直观，易于理解和实现
- ✅ **稳定性好**：运行时间波动小，最大时间仅99.3ms
- ✅ **可扩展性强**：适用于任意规模的问题，时间增长缓慢

**缺点**：
- ❌ **解质量有限**：最优解概率仅74%，约1/4的实例无法达到最优
- ❌ **可能陷入局部最优**：贪心策略无法保证全局最优性
- ❌ **无理论保证**：虽然使用最小费用最大流进行用户分配，但选址策略本身是贪心的

**适用场景**：
- 需要快速响应的实时决策系统
- 大规模问题的初步筛选
- 作为其他算法的初始解生成器

---

##### MILP求解器

**优点**：
- ✅ **保证最优解**：在所有测试实例上都能找到最优解（100%最优解概率）
- ✅ **运行时间短**：平均43.5ms，中位数24.2ms，大多数情况下非常快
- ✅ **理论保证强**：基于分支定界法，可以给出最优性证明
- ✅ **适用规模广**：在测试的所有规模（$m \leq 15$）上都能有效工作

**缺点**：
- ❌ **时间波动大**：虽然平均时间短，但最大时间可达327.4ms，个别实例可能需要较长时间
- ❌ **规模限制**：虽然测试中$m=15$仍可工作，但理论上$m$继续增大时求解时间会急剧增长
- ❌ **依赖求解器**：需要安装PuLP和CBC等求解器，对系统环境有要求

**适用场景**：
- 需要保证最优解的中等规模问题
- 作为其他算法的基准验证
- 对解质量要求高的应用场景

---

##### 暴力枚举

**优点**：
- ✅ **小规模保证最优**：在$m \leq 12$时，100%找到最优解
- ✅ **实现简单**：算法逻辑直接，易于理解和验证
- ✅ **结果可靠**：作为基准算法，可以验证其他算法的正确性

**缺点**：
- ❌ **指数爆炸**：时间复杂度$O(2^m)$，$m$增大时时间急剧增长
- ❌ **规模限制严格**：$m=15$时达到时间限制，完全无法完成枚举
- ❌ **实际应用受限**：仅适用于非常小规模的问题（$m \leq 12$）

**适用场景**：
- 小规模问题的精确求解（$m \leq 12$）
- 算法正确性验证的基准
- 教学和理论研究

---

##### 遗传算法

**优点**：
- ✅ **解质量高**：最优解概率96%，接近最优解
- ✅ **可扩展性好**：在所有测试规模上都能工作，包括$m=15$的大规模问题
- ✅ **时间稳定**：运行时间相对稳定，不会出现极端情况
- ✅ **早停机制**：如果提前收敛可以提前终止，提高效率
- ✅ **可并行化**：种群评估可以并行进行，进一步提升速度

**缺点**：
- ❌ **运行时间较长**：平均4.204s，比贪心和MILP慢得多
- ❌ **无理论保证**：作为元启发式算法，不能保证找到最优解
- ❌ **参数敏感**：需要调优种群大小、交叉率、变异率等参数
- ❌ **大规模时性能下降**：$m=15$时最优解概率降至80%

**适用场景**：
- 大规模问题的近似最优求解（$m > 15$）
- 对解质量要求较高但可以接受近似解的场景
- 有充足计算资源的情况

#### 4.8.4 综合建议

根据实验数据分析，针对不同的问题规模和需求，建议如下：

1. **小规模问题**（$m \leq 10$）：
   - **首选**：MILP求解器（保证最优，速度快）
   - **备选**：暴力枚举（$m \leq 8$时）或贪心算法（需要快速响应时）

2. **中等规模问题**（$10 < m \leq 15$）：
   - **首选**：MILP求解器（保证最优，时间可接受）
   - **备选**：遗传算法（如果MILP时间过长）或贪心算法（需要快速响应时）

3. **大规模问题**（$m > 15$）：
   - **首选**：遗传算法（解质量高，时间可接受）
   - **备选**：贪心算法（需要快速响应时）

4. **实时决策系统**：
   - **首选**：贪心算法（速度最快，解质量可接受）

5. **需要保证最优解**：
   - **唯一选择**：MILP求解器（在所有规模下都能保证最优解）

#### 4.8.5 实验结论

1. **统一策略的有效性**：所有算法采用统一的最优分配策略（最小费用最大流），确保了算法比较的公平性，也证明了该策略的有效性。

2. **MILP求解器的优势**：在所有测试规模下都能保证100%找到最优解，且运行时间在大多数情况下很短，是中等规模问题的首选方法。

3. **贪心算法的实用性**：虽然解质量有限（74%最优解概率），但其极快的速度（平均30.7ms）使其在实际应用中具有重要价值。

4. **遗传算法的平衡性**：在解质量（96%最优解概率）和运行时间（平均4.2s）之间取得了良好的平衡，适合大规模问题。

5. **暴力枚举的局限性**：虽然在小规模问题上表现完美，但其指数复杂度限制了其实际应用范围。