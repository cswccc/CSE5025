# 充电桩覆盖收益最大化问题求解

本项目实现了多种算法来解决充电桩选址与配置的组合优化问题，目标是在预算和容量约束条件下，最大化覆盖用户带来的总收益减去建设成本的净收益。

## 问题描述

### 数学模型

给定：
- **n** 栋居民楼，每栋楼有潜在用户需求 $D_i$ 和单位收益 $p_i$
- **m** 个可选充电桩区域，每个区域有建设成本 $c_j$ 和容量上限 $U_j$
- 覆盖关系矩阵 $a_{ij}$：表示区域 $j$ 是否可以覆盖楼栋 $i$

决策变量：
- $z_j \in \{0,1\}$：是否在区域 $j$ 建设
- $x_j \geq 0$：区域 $j$ 设置的充电桩数量
- $y_{ij} \geq 0$：楼栋 $i$ 分配到区域 $j$ 的用户人数

目标函数：
$$\max \sum_{i=1}^{n} \sum_{j=1}^{m} p_i y_{ij} - \sum_{j=1}^{m} c_j z_j$$

约束条件：
1. 覆盖关系约束：$y_{ij} \leq D_i \cdot a_{ij} \cdot z_j$
2. 需求约束：$\sum_j y_{ij} \leq D_i$
3. 容量约束：$\sum_i y_{ij} \leq x_j$
4. 容量上限约束：$0 \leq x_j \leq U_j \cdot z_j$

## 项目结构

```
Project/
├── data_generator.py          # 数据生成模块
├── main.py                    # 主程序
├── requirements.txt           # 依赖包
├── README.md                  # 本文档
├── solvers/                   # 求解器模块
│   ├── __init__.py
│   ├── base_solver.py        # 基础求解器类
│   ├── brute_force.py        # 暴力枚举法
│   ├── greedy.py             # 贪心算法
│   ├── milp_solver.py        # MILP求解器（PuLP）
│   ├── genetic_algorithm.py  # 遗传算法
│   ├── ant_colony.py         # 蚁群算法
│   └── neural_network.py     # 神经网络方法
└── 充电桩覆盖收益最大化.pdf   # 问题描述文档
```

## 安装依赖

```bash
pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/
```

主要依赖：
- `numpy`: 数值计算
- `pulp`: MILP求解器（可选，用于精确求解）
- `torch`: 神经网络方法（可选，用于深度学习方法）

## 使用方法

### 1. 生成问题实例

```bash
python data_generator.py
```

或使用主程序生成：

```bash
python main.py --generate --n 20 --m 10
```

### 2. 运行求解器

```bash
# 运行所有求解器
python main.py --generate --methods all

# 运行特定求解器
python main.py --generate --methods greedy milp ga

# 使用已有问题实例
python main.py --instance instance.json --methods all
```

### 命令行参数

- `--generate`: 生成新的问题实例
- `--instance FILE`: 指定问题实例JSON文件
- `--n N`: 楼栋数量（默认20）
- `--m M`: 区域数量（默认10）
- `--methods METHOD [METHOD ...]`: 指定要运行的求解方法
  - `brute_force`: 暴力枚举法
  - `greedy`: 贪心算法
  - `milp`: MILP求解器
  - `ga`: 遗传算法
  - `aco`: 蚁群算法
  - `nn`: 神经网络方法
  - `all`: 运行所有方法
- `--output FILE`: 结果输出文件（默认results.json）

## 数据生成逻辑

### 参数说明

数据生成器（`data_generator.py`）生成以下参数：

1. **楼栋需求 $D_i$**: 
   - 范围：[`min_demand`, `max_demand`]（默认10-100）
   - 生成方式：均匀随机整数

2. **单位收益 $p_i$**: 
   - 范围：[`min_profit`, `max_profit`]（默认1.0-10.0）
   - 生成方式：均匀随机浮点数

3. **建设成本 $c_j$**: 
   - 范围：[`min_cost`, `max_cost`]（默认50.0-500.0）
   - 生成方式：均匀随机浮点数

4. **容量上限 $U_j$**: 
   - 范围：[`min_capacity`, `max_capacity`]（默认20-200）
   - 生成方式：均匀随机整数

5. **覆盖关系矩阵 $a_{ij}$**: 
   - 生成方式：伯努利分布，每个位置以 `coverage_rate` 的概率为1（默认0.3）
   - 保证每个楼栋至少被一个区域覆盖
   - 保证每个区域至少覆盖一个楼栋

### 生成示例

```python
from data_generator import DataGenerator

generator = DataGenerator(seed=42)
instance = generator.generate_instance(
    n=20,              # 20栋楼
    m=10,              # 10个区域
    coverage_rate=0.3  # 30%覆盖率
)
generator.save_instance(instance, "my_instance.json")
```

## 求解方法说明

### 1. 暴力枚举法 (Brute Force)

**文件**: `solvers/brute_force.py`

**算法逻辑**:
- 枚举所有可能的建设决策组合（$2^m$ 种方案）
- 对于每种建设方案，使用贪心方法快速求解最优的用户分配
- 选择目标函数值最大的解

**优点**:
- 保证找到最优解（对于枚举的范围内）

**缺点**:
- 时间复杂度：$O(2^m)$，仅适用于小规模问题（$m \leq 15$）

**适用场景**: 小规模问题（区域数量 $\leq 15$）

---

### 2. 贪心算法 (Greedy Algorithm)

**文件**: `solvers/greedy.py`

**算法逻辑**:
1. 计算每个区域的"性价比"（潜在收益/建设成本）
2. 按性价比从高到低排序区域
3. 依次尝试添加每个区域，如果目标函数提升则保留
4. 对选中的区域，贪心分配用户（按单位收益从高到低）

**优点**:
- 运行速度快
- 实现简单

**缺点**:
- 不能保证全局最优
- 可能陷入局部最优

**适用场景**: 快速获取可行解，作为其他算法的初始解

---

### 3. MILP求解器 (Mixed Integer Linear Programming)

**文件**: `solvers/milp_solver.py`

**算法逻辑**:
- 将问题建模为标准的混合整数线性规划模型
- 使用PuLP库调用CBC求解器求解
- 得到精确的最优解（或最优界）

**优点**:
- 保证找到最优解（如果求解器收敛）
- 可以给出最优性证明

**缺点**:
- 对于大规模问题可能求解时间很长
- 需要安装PuLP库

**适用场景**: 中等规模问题，需要精确解

---

### 4. 遗传算法 (Genetic Algorithm)

**文件**: `solvers/genetic_algorithm.py`

**算法逻辑**:
1. **编码**: 将建设决策 $z$ 编码为二进制串（染色体）
2. **初始化**: 随机生成初始种群
3. **适应度评估**: 对每个个体解码（贪心分配用户）并计算目标函数值
4. **选择**: 轮盘赌选择，适应度高的个体被选中概率大
5. **交叉**: 单点交叉，生成子代
6. **变异**: 随机翻转某些位，引入多样性
7. **精英保留**: 保留最优的个体到下一代
8. 重复步骤3-7直到达到最大代数

**参数**:
- `pop_size`: 种群大小（默认50）
- `max_generations`: 最大代数（默认100）
- `crossover_rate`: 交叉率（默认0.8）
- `mutation_rate`: 变异率（默认0.1）
- `elite_rate`: 精英比例（默认0.1）

**优点**:
- 可以跳出局部最优
- 适合大规模问题

**缺点**:
- 不能保证最优
- 参数需要调优

**适用场景**: 大规模问题，需要近似最优解

---

### 5. 蚁群算法 (Ant Colony Optimization)

**文件**: `solvers/ant_colony.py`

**算法逻辑**:
1. **信息素初始化**: 为每个区域初始化信息素浓度
2. **启发式信息**: 计算每个区域的性价比作为启发式信息
3. **解构造**: 每只蚂蚁根据信息素和启发式信息按概率选择区域
4. **信息素更新**: 
   - 信息素挥发：$\tau_j = (1-\rho)\tau_j$
   - 信息素增强：根据解的质量增加信息素
   - 最优解额外增强
5. 重复步骤3-4直到达到最大迭代次数

**参数**:
- `num_ants`: 蚂蚁数量（默认20）
- `max_iterations`: 最大迭代次数（默认100）
- `alpha`: 信息素重要程度（默认1.0）
- `beta`: 启发式信息重要程度（默认2.0）
- `rho`: 信息素挥发系数（默认0.1）
- `q`: 信息素强度（默认100.0）

**优点**:
- 具有良好的全局搜索能力
- 适合组合优化问题

**缺点**:
- 收敛速度可能较慢
- 参数敏感

**适用场景**: 中等规模问题，需要高质量近似解

---

### 6. 神经网络方法 (Neural Network)

**文件**: `solvers/neural_network.py`

**算法逻辑**:
1. **特征提取**: 为每个区域提取特征向量（成本、容量、覆盖楼栋数、平均收益）
2. **策略网络**: 使用全连接神经网络学习区域选择策略
   - 输入：区域特征
   - 输出：选择该区域的概率
3. **策略梯度训练**:
   - 根据当前策略采样建设决策
   - 计算奖励（目标函数值）
   - 使用策略梯度方法更新网络参数
4. **解生成**: 使用训练好的网络生成最终解

**网络结构**:
- 输入层：4维特征向量
- 隐藏层：2层，每层64个神经元，ReLU激活
- 输出层：1维，Sigmoid激活（表示选择概率）

**参数**:
- `hidden_dim`: 隐藏层维度（默认64）
- `learning_rate`: 学习率（默认0.001）
- `num_episodes`: 训练回合数（默认1000）
- `batch_size`: 批次大小（默认32）

**优点**:
- 可以学习复杂的选择模式
- 适合处理大规模问题

**缺点**:
- 需要训练时间
- 不能保证最优
- 需要安装PyTorch

**适用场景**: 大规模问题，有充足的计算资源

---

### 7. 动态规划方法

**注意**: 由于该问题的约束条件复杂（覆盖关系、容量限制、多楼栋多区域），传统的动态规划方法难以直接应用。问题的状态空间太大，且不具有典型的递归最优子结构。因此本项目未实现动态规划方法。

如果问题规模很小且具有特定的结构，可以考虑使用状态压缩动态规划，但通用性较差。

## 结果输出

程序会输出JSON格式的结果文件，包含：
- 问题实例参数
- 各求解器的结果（目标值、运行时间、可行性、解详情）
- 最佳求解器信息

示例输出：
```json
{
  "instance": {...},
  "results": [
    {
      "solver": "贪心算法",
      "objective": 1234.56,
      "time": 0.0123,
      "feasible": true,
      "solution": {
        "z": [1, 0, 1, ...],
        "x": [10.0, 0.0, 15.0, ...],
        "y": [[...], [...]]
      }
    },
    ...
  ],
  "best_solver": "MILP求解器",
  "best_objective": 1250.78
}
```

## 性能比较

不同方法的适用场景和建议：

| 方法 | 适用规模 | 求解时间 | 解质量 | 保证最优 |
|------|---------|---------|--------|---------|
| 暴力枚举 | 很小 (m≤15) | 长 | 最优 | ✓ |
| 贪心算法 | 任意 | 很短 | 较好 | ✗ |
| MILP | 中小 | 中等 | 最优 | ✓ |
| 遗传算法 | 大规模 | 中等 | 好 | ✗ |
| 蚁群算法 | 中大规模 | 中等 | 很好 | ✗ |
| 神经网络 | 大规模 | 长（训练） | 好 | ✗ |

## 扩展建议

1. **并行化**: 遗传算法和蚁群算法可以并行化加速
2. **混合算法**: 结合多种方法的优点，如用贪心生成初始解，再用元启发式算法优化
3. **启发式改进**: 对得到的解进行局部搜索改进
4. **问题变体**: 考虑更多约束，如预算限制、时间窗口等

## 参考文献

- 问题描述见：`充电桩覆盖收益最大化.pdf`
- MILP建模参考：混合整数线性规划相关文献
- 元启发式算法：遗传算法、蚁群算法相关文献

## 许可证

本项目仅用于学术研究和教学目的。

## 联系方式

如有问题或建议，请提交Issue或联系项目维护者。
