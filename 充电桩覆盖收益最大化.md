# 充电桩覆盖收益最大化问题

## 第一章 问题背景与描述

### 1.1 问题场景

考虑如下的组合优化问题。设有一座城市，共有若干居民楼，总数记为 $n \in \mathbb{Z}_+$，楼栋索引集合为 $\mathcal{I} = \{1,2,\dots,n\}$。对于每一栋楼 $i \in \mathcal{I}$，已知其潜在需要使用电动车充电桩的总人数为 $D_i \ge 0$，且每覆盖其中一名用户即可带来单位收益 $p_i \ge 0$，该收益因楼而异。规划部门预先给出了 $m$ 个可选的充电桩区域，区域索引集合为 $\mathcal{J} = \{1,2,\dots,m\}$。每个区域 $j \in \mathcal{J}$ 所能服务的楼栋集合是给定的，用覆盖关系矩阵 $a_{ij} \in \{0, 1\}$ 表示，不同区域之间的覆盖范围可以重叠，即可能存在某些楼栋同时属于多个区域的覆盖范围。若选择建设区域 $j$，则需要支付一笔固定建设成本 $c_j \ge 0$，该成本可包含土建、配电、设备安装及相关手续费用等。在区域 $j$ 内可以设置若干个充电桩，设其数量为 $x_j$，但受物理条件、规划或容量约束，每个区域可设置的充电桩数量存在上限 $U_j \in \mathbb{Z}_+$，超过这一上限在实际规划中不可行。为简化模型，假定每个充电桩可以服务一个"单位用户"（或认为每个桩的服务能力已折算为统一的用户单位），从而区域 $j$ 实际可服务的用户总数上界为 $x_j$。

我们的目标是在预算和容量约束条件下，决定哪些区域需要建设以及在每个已建设区域中设置多少个充电桩，并在覆盖关系限制下将各楼栋的用户分配到相应区域，使"覆盖用户带来的总收益减去建设成本"的净收益最大化。

---

## 第二章 数学建模

### 2.1 参数定义

**集合与索引：**
- $\mathcal{I} = \{1,2,\dots,n\}$：楼栋索引集合，$n$ 为楼栋总数
- $\mathcal{J} = \{1,2,\dots,m\}$：区域索引集合，$m$ 为候选区域总数

**输入参数：**
- $D_i \ge 0$：楼栋 $i$ 的潜在用户总数
- $p_i \ge 0$：楼栋 $i$ 每覆盖一个用户带来的收益
- $c_j \ge 0$：区域 $j$ 的固定建设成本
- $U_j \in \mathbb{Z}_+$：区域 $j$ 的充电桩数量上限
- $a_{ij} \in \{0,1\}$：覆盖关系矩阵，$a_{ij} = 1$ 表示区域 $j$ 可以覆盖楼栋 $i$

### 2.2 决策变量

为刻画这一决策过程，引入如下决策变量：

**1. 建设决策变量**

对每个区域 $j \in \mathcal{J}$ 定义 0–1 决策变量

$$
z_j =
\begin{cases}
1, & \text{若在区域 } j \text{ 建设充电桩区域},\\
0, & \text{否则}。
\end{cases}
$$

变量 $z_j$ 表示是否选择在区域 $j$ 进行建设。

**2. 充电桩配置变量**

用变量 $x_j$ 表示在区域 $j$ 内设置的充电桩数量。为了反映桩数的离散性，规定 $x_j \in \mathbb{Z}_+$。

**3. 用户分配变量**

用变量 $y_{ij}$ 表示楼栋 $i$ 中被分配到区域 $j$ 进行充电的用户人数，对所有楼栋–区域对 $(i,j)$ 规定 $y_{ij} \ge 0$。

### 2.3 约束条件

**1. 覆盖与建设逻辑约束**

由于只有在区域 $j$ 能够覆盖楼栋 $i$ 且该区域被建设的情况下，才允许将楼栋 $i$ 的用户分配到区域 $j$，因此可以通过如下约束刻画这一逻辑关系：

$$
y_{ij} \le D_i\, a_{ij}\, z_j,\quad \forall i \in \mathcal{I},\ \forall j \in \mathcal{J}.
$$

当 $a_{ij} = 0$ 或 $z_j = 0$ 时，上述约束强制 $y_{ij} = 0$，从而禁止在未覆盖或未建设的区域中为该楼栋分配用户。

**2. 用户需求约束**

每栋楼的用户总数不能被超额分配，即对每个 $i \in \mathcal{I}$ 有

$$
\sum_{j \in \mathcal{J}} y_{ij} \le D_i,
$$

这表示来自楼栋 $i$ 的所有分配人数总和不得超过其潜在需求 $D_i$。

**3. 区域容量约束**

区域 $j$ 的服务能力受到其内部充电桩数量的限制。由于假定每个桩可服务一个单位用户，因此区域 $j$ 能服务的用户总数上界为 $x_j$，从而对每个 $j \in \mathcal{J}$ 有容量约束

$$
\sum_{i \in \mathcal{I}} y_{ij} \le x_j.
$$

**4. 充电桩数量联动约束**

充电桩数量又受到区域上限的控制，并且只有在区域被建设时才允许设置充电桩，为此对每个 $j \in \mathcal{J}$ 引入联动约束

$$
0 \le x_j \le U_j\, z_j.
$$

当 $z_j = 0$ 时，该约束强制 $x_j = 0$，表示未建设的区域不能配置充电桩；当 $z_j = 1$ 时则允许 $x_j$ 在区间 $[0, U_j]$ 内取值。

**5. 变量类型约束**

$$
z_j \in \{0,1\},\quad x_j \ge 0,\quad y_{ij} \ge 0,\quad \forall i \in \mathcal{I},\ \forall j \in \mathcal{J}.
$$

### 2.4 目标函数

**1. 总收益计算**

所有被成功覆盖的用户带来的总收益可以表示为

$$
\sum_{i \in \mathcal{I}} \sum_{j \in \mathcal{J}} p_i\, y_{ij}.
$$

**2. 总成本计算**

为建设各个区域支付的总固定成本为

$$
\sum_{j \in \mathcal{J}} c_j\, z_j.
$$

**3. 净收益目标函数**

我们希望最大化的净收益（即总收益减去总成本）为

$$
\sum_{i \in \mathcal{I}} \sum_{j \in \mathcal{J}} p_i\, y_{ij} \;-\; \sum_{j \in \mathcal{J}} c_j\, z_j.
$$

### 2.5 完整数学规划模型

将上述目标函数与约束条件综合起来，可以得到该充电桩选址与配置问题的形式化数学规划模型：

$$
\begin{aligned}
\max_{z,x,y}\quad & \sum_{i \in \mathcal{I}} \sum_{j \in \mathcal{J}} p_i\, y_{ij} \;-\; \sum_{j \in \mathcal{J}} c_j\, z_j,\\
\text{s.t.}\quad 
& y_{ij} \le D_i\, a_{ij}\, z_j,\quad && \forall i \in \mathcal{I},\ \forall j \in \mathcal{J},\\[4pt]
& \sum_{j \in \mathcal{J}} y_{ij} \le D_i,\quad && \forall i \in \mathcal{I},\\[4pt]
& \sum_{i \in \mathcal{I}} y_{ij} \le x_j,\quad && \forall j \in \mathcal{J},\\[4pt]
& 0 \le x_j \le U_j\, z_j,\quad && \forall j \in \mathcal{J},\\[4pt]
& z_j \in \{0,1\},\ x_j \ge 0,\ y_{ij} \ge 0,\quad && \forall i \in \mathcal{I},\ \forall j \in \mathcal{J}.
\end{aligned}
$$

该模型刻画了在存在覆盖重叠、建设成本以及容量上限等现实约束条件下，如何选择建设哪些充电区域并配置相应数量的充电桩，以及如何将不同楼栋的用户分配到各个区域，从而最大化总体经济收益的组合优化问题，本质上属于一个**混合整数线性规划**模型。

---

## 第三章 复杂度分析与规约证明

### 3.1 判定问题的形式化

在前面给出的数学模型基础上，下面从计算复杂度的角度，对该充电桩选址与配置问题进行形式化分析，给出其判定版本属于 NP，并通过从集合覆盖（Set Cover）问题的多项式时间规约证明该问题是 NP-hard，从而其判定版本为 NP-complete，优化版本为 NP-hard。

我们先将原始的**优化问题**改写为一个**判定问题**。给定参数
- 楼栋集合 $\mathcal{I} = \{1,\dots,n\}$，区域集合 $\mathcal{J} = \{1,\dots,m\}$；
- 潜在需求 $D_i \ge 0$，单位收益 $p_i \ge 0$；
- 区域固定成本 $c_j \ge 0$，最大桩数上限 $U_j \in \mathbb{Z}_+$；
- 覆盖关系矩阵 $a_{ij} \in \{0,1\}$；
- 以及目标阈值 $K \in \mathbb{R}$，

考虑如下判定问题：

> **充电桩选址判定问题**：是否存在一组决策变量 $(z,x,y)$ 满足所有约束  
> $$
> \begin{aligned}
> & y_{ij} \le D_i a_{ij} z_j,\quad && \forall i\in\mathcal{I},\ \forall j\in\mathcal{J},\\
> & \sum_{j\in\mathcal{J}} y_{ij} \le D_i,\quad && \forall i\in\mathcal{I},\\
> & \sum_{i\in\mathcal{I}} y_{ij} \le x_j,\quad && \forall j\in\mathcal{J},\\
> & 0 \le x_j \le U_j z_j,\quad && \forall j\in\mathcal{J},\\
> & z_j\in\{0,1\},\ x_j\ge 0,\ y_{ij}\ge 0,\quad && \forall i\in\mathcal{I},\ \forall j\in\mathcal{J},
> \end{aligned}
> $$
> 且目标函数满足
> $$
> \sum_{i\in\mathcal{I}}\sum_{j\in\mathcal{J}} p_i\, y_{ij} - \sum_{j\in\mathcal{J}} c_j\, z_j \;\ge K\ ?
> $$

### 3.2 判定问题属于 NP

给定一个候选解 $(z,x,y)$，我们可以在多项式时间内验证它是否为一个"证据"（certificate）：

**1. 检查线性约束**

对每个 $(i,j)$ 检查  
$y_{ij} \le D_i a_{ij} z_j$，  
对每个 $i$ 检查 $\sum_{j} y_{ij} \le D_i$，  
对每个 $j$ 检查 $\sum_{i} y_{ij} \le x_j$ 和 $0 \le x_j \le U_j z_j$。  
这些都是有限个线性不等式，个数为 $\mathcal{O}(nm+n+m)$，逐一计算和比较的时间是多项式的。

**2. 检查变量类型**

对每个 $j$ 检查 $z_j\in\{0,1\}$，对每个 $j$ 检查 $x_j\ge 0$，对每个 $(i,j)$ 检查 $y_{ij}\ge 0$，不等式个数为$\mathcal{O}(nm)$，计算时间也是多项式的。

**3. 计算目标函数并比较阈值**

在 $\mathcal{O}(nm + m)$ 时间内计算
$$
\sum_{i\in\mathcal{I}}\sum_{j\in\mathcal{J}} p_i\, y_{ij} - \sum_{j\in\mathcal{J}} c_j\, z_j
$$
并与给定阈值 $K$ 做一次比较即可。

假设所有输入参数（包括 $D_i,p_i,c_j,U_j,a_{ij},K$ 等）都以二进制编码给出，则上述检验步骤的时间复杂度为输入规模的多项式。因此，该判定问题属于类 $\mathrm{NP}$：一旦给出一个候选解，就可以在多项式时间内验证其可行性以及目标值是否达到阈值 $K$。

### 3.3 从 Set Cover 的规约

为了证明该问题是 NP-hard，我们从经典的集合覆盖问题（Set Cover）构造一个多项式时间规约。

#### 3.3.1 集合覆盖问题回顾

集合覆盖判定问题定义如下：

- 给定一个有限集合（宇宙）  
  $$
  U = \{e_1,e_2,\dots,e_n\},
  $$
- 一族子集  
  $$
  \mathcal{S} = \{S_1,S_2,\dots,S_m\},\quad S_j \subseteq U,
  $$
- 以及一个正整数 $k$，

问：是否存在一个索引集合 $J^\star \subseteq \{1,\dots,m\}$，满足 $|J^\star| \le k$ 且
$$
\bigcup_{j\in J^\star} S_j = U\ ?
$$

该问题是著名的 NP-complete 问题。我们将证明：对任意一个 Set Cover 实例 $(U,\mathcal{S},k)$，都可以在多项式时间内构造一个充电桩选址判定实例，使得前者存在规模不超过 $k$ 的覆盖当且仅当后者存在一个目标值不小于某一阈值 $K$ 的可行解。

#### 3.3.2 规约构造步骤

给定 Set Cover 实例 $(U,\mathcal{S},k)$，其中
$$
U = \{e_1,\dots,e_n\},\quad
\mathcal{S} = \{S_1,\dots,S_m\},
$$
我们按如下方式构造一个充电桩选址实例。

**步骤 1：楼栋与元素对应**

将每个元素 $e_i\in U$ 对应为一栋楼 $i$。于是楼栋集合为
$$
\mathcal{I} = \{1,\dots,n\},\quad n = |U|.
$$
对每栋楼 $i$ 设置潜在需求
$$
D_i = 1,\quad \forall i\in\mathcal{I},
$$
即每个元素只需要"被服务"一次。为简化，将每个被覆盖用户的收益设置为统一常数：
$$
p_i = M,\quad \forall i\in\mathcal{I},
$$
其中常数 $M$ 取为
$$
M = m + 1.
$$

**步骤 2：区域与子集对应**

将每个子集 $S_j$ 对应为一个候选区域 $j$。于是区域集合为
$$
\mathcal{J} = \{1,\dots,m\},\quad m = |\mathcal{S}|.
$$
定义覆盖关系矩阵 $a_{ij}$ 为
$$
a_{ij} =
\begin{cases}
1, & \text{若 } e_i \in S_j,\\
0, & \text{否则},
\end{cases}
\qquad \forall i\in\mathcal{I},\ \forall j\in\mathcal{J},
$$
即区域 $j$ 正好覆盖集合 $S_j$ 对应的那些楼栋。

**步骤 3：容量与建设成本**

为避免容量约束人为限制，令每个区域的最大桩数上限足够大，例如
$$
U_j = n,\quad \forall j\in\mathcal{J},
$$
并允许 $x_j$ 足以服务所有其覆盖的楼栋（因为每栋最多 1 个用户）。区域建设成本设为常数
$$
c_j = 1,\quad \forall j\in\mathcal{J},
$$
即每选一个区域的成本为 1。在容量足够大的情况下，只要 $z_j = 1$，就完全可以为该区域能覆盖到的楼栋提供服务。

**步骤 4：阈值设定**

在该充电问题上，我们关注如下目标函数：
$$
\text{Profit}(z,x,y) = 
\sum_{i\in\mathcal{I}}\sum_{j\in\mathcal{J}} p_i\, y_{ij} - \sum_{j\in\mathcal{J}} c_j\, z_j.
$$

在上述构造下，由于 $D_i = 1$，每个楼栋 $i$ 要么完全被某个区域服务（贡献 $M$ 的收益），要么完全未被服务（贡献 $0$）。记被成功覆盖的楼栋集合为
$$
C(J) = \{i\in\mathcal{I} : \text{存在 } j\in\mathcal{J} \text{ 使 } y_{ij} = 1\},
$$
记被选择的区域集合为
$$
J = \{j\in\mathcal{J}: z_j = 1\}.
$$

此时可以将目标函数重写为
$$
\text{Profit}(J) = M\cdot |C(J)| - |J|.
$$

我们在规约中选择阈值
$$
K = M n - k.
$$

**步骤 5：构造规模与时间**

从 $(U,\mathcal{S},k)$ 构造上述参数 $D_i,p_i,c_j,U_j,a_{ij},K$ 的过程，只需要遍历所有元素和子集，计算 $a_{ij}$，其时间复杂度为多项式（约为 $\mathcal{O}(nm)$），因此该规约是多项式时间的。

### 3.4 规约正确性证明

我们证明如下的等价性命题：

> **命题**：原 Set Cover 实例存在一个大小不超过 $k$ 的集合覆盖  
> 当且仅当  
> 构造的充电选址实例存在一个可行解使  
> $$
> \text{Profit}(z,x,y) \ge K = M n - k.
> $$

#### 3.4.1 充分性证明

**如果存在集合覆盖，则存在利润至少为 $K$ 的解**

假设在 Set Cover 实例中，存在一个索引集合 $J^\star \subseteq \{1,\dots,m\}$，满足
$$
|J^\star| \le k,\quad \bigcup_{j\in J^\star} S_j = U.
$$

在充电实例中构造如下解：

- 对 $j\in J^\star$，令 $z_j = 1$；对 $j\notin J^\star$，令 $z_j = 0$；
- 对每个选择的区域 $j\in J^\star$，取足够多的桩数（例如 $x_j = n$），显然满足 $x_j \le U_j z_j$；
- 由于 $J^\star$ 是集合覆盖，对每个楼栋 $i$，至少存在某个 $j\in J^\star$ 使 $a_{ij} = 1$。从中任取一个区域 $j$，令 $y_{ij} = 1$，其余 $y_{ij'} = 0$。这样对所有楼栋 $i$ 都有 $\sum_{j} y_{ij} = 1 \le D_i$，并且对每个区域 $j$ 有
  $$
  \sum_{i} y_{ij} \le n = x_j,
  $$
  所有约束均被满足。

此时所有楼栋都被覆盖，即 $C(J^\star) = \mathcal{I}$，从而 $|C(J^\star)| = n$。目标函数为
$$
\text{Profit}(J^\star) = M n - |J^\star|
\ge M n - k = K.
$$

因此，若 Set Cover 实例有大小不超过 $k$ 的覆盖，则充电实例中存在一个可行解使目标值至少为 $K$。

#### 3.4.2 必要性证明

**如果存在利润至少为 $K$ 的解，则存在大小不超过 $k$ 的集合覆盖**

反方向，假设在充电实例中存在一个可行解 $(z,x,y)$，对应的区域集合
$$
J = \{j\in\mathcal{J} : z_j = 1\},
$$
满足
$$
\text{Profit}(J) = M |C(J)| - |J| \ge K = M n - k.
$$

首先证明该解必须覆盖所有楼栋，即 $|C(J)| = n$。

若存在某个楼栋 $i$ 未被服务，则 $i\notin C(J)$，因此 $|C(J)| \le n-1$。注意 $|J|\ge 0$，故有
$$
\text{Profit}(J) = M|C(J)| - |J|
\le M (n-1) - 0 = M(n-1).
$$

而
$$
K = M n - k \ge M n - m.
$$

代入 $M = m + 1$，得到
$$
M n - m = (m+1)n - m = (m+1)(n-1) + (m+1 - m)
= M (n-1) + 1.
$$

于是
$$
K \ge M(n-1) + 1 > M(n-1).
$$

这与 $\text{Profit}(J) \le M(n-1)$ 和 $\text{Profit}(J) \ge K$ 矛盾。因此，任何满足 $\text{Profit}(J)\ge K$ 的可行解必须满足 $|C(J)| = n$，即所有楼栋都被覆盖。

在 $|C(J)| = n$ 的情况下，目标函数化简为
$$
\text{Profit}(J) = M n - |J|.
$$

条件 $\text{Profit}(J)\ge K = M n - k$ 等价于
$$
M n - |J| \ge M n - k
\quad\Longleftrightarrow\quad
|J| \le k.
$$

由于 $|C(J)| = n$，说明对每个楼栋 $i$ 都存在 $j\in J$ 使 $a_{ij}=1$，也即
$$
\{e_i : i\in\mathcal{I}\} \subseteq \bigcup_{j\in J} S_j.
$$

由构造中楼栋与元素一一对应可知
$$
\bigcup_{j\in J} S_j = U,
$$
且 $|J|\le k$。这说明集合 $J$ 在原 Set Cover 实例中给出了一个大小不超过 $k$ 的集合覆盖。

综上，如果在充电实例中存在利润不小于 $K$ 的可行解，则相应地在 Set Cover 实例中存在一个规模不超过 $k$ 的集合覆盖。

### 3.5 复杂度结论

上述构造在输入规模的多项式时间内完成，并且满足
- Set Cover 实例为 "Yes" 当且仅当
- 对应的充电选址判定实例为 "Yes"（存在解使目标值 $\ge K$）。

因此，我们得到从 Set Cover 判定问题到充电桩选址判定问题的多项式时间规约。由于 Set Cover 判定问题是 NP-complete，且我们的充电判定问题已证明属于 NP，由此可知：

- **充电桩选址判定问题是 NP-complete**；
- **相应的优化问题（最大化利润）是 NP-hard**。

这意味着在一般情况下，除非 $\mathrm{P} = \mathrm{NP}$，不存在多项式时间算法可以求得该优化问题的全局最优解；该问题在复杂度意义上属于典型的组合优化难题。


## 第四章 算法设计

### 4.1 统一的最优分配策略：最小费用最大流方法

所有求解算法都采用以下统一的子问题求解策略：一旦选址决策 $z$ 确定，充电桩数量 $x$ 直接设置为容量上限（$x_j = U_j \cdot z_j$），然后使用**最小费用最大流算法**精确求解最优的用户分配 $y$。

#### 4.1.1 核心思想与理论依据

**核心观察**：由于增加充电桩不会带来额外的边际成本（只有固定的建设成本 $c_j$），对于选中的区域，将充电桩数量设置为上限总是最优的。因此，子问题简化为：给定建设决策 $z$ 和 $x_j = U_j \cdot z_j$，如何最优分配用户 $y$？

**理论依据**：
- 固定 $z$ 和 $x$ 后，用户分配子问题可以建模为最小费用最大流问题
- 最小费用最大流问题可在多项式时间内精确求解，复杂度为 $O((n+m)^2 \times \log(n+m) \times C)$
- 由于网络流问题的约束矩阵是全幺模（totally unimodular）矩阵，算法会自动返回整数解，保证 $y_{ij} \in \mathbb{Z}_+$

#### 4.1.2 网络流建模

将用户分配问题转化为最小费用最大流问题：

**网络结构**：
- **节点集合**：$\{s, t\} \cup \mathcal{I} \cup S$，其中 $S = \{j \in \mathcal{J} : z_j = 1\}$ 是已选中的区域集合
  - 源点 $s$
  - 楼栋节点 $i$（$n$ 个）
  - 区域节点 $j$（仅包括 $j \in S$）
  - 汇点 $t$

**有向边及其容量和费用**：
1. **源点到楼栋**：$s \to i$，容量 $D_i$，费用 $0$
2. **楼栋到区域**：$i \to j$（当 $a_{ij} = 1$ 且 $z_j = 1$ 时存在），容量 $D_i$，费用 $-p_i$
3. **区域到汇点**：$j \to t$（$j \in S$），容量 $U_j \cdot z_j = U_j$，费用 $0$
4. **楼栋直接到汇点**：$i \to t$，容量 $D_i$，费用 $0$（表示未被服务的用户）

**流量平衡**：

- 源点 $s$ 的供给：$\sum_i D_i$
- 汇点 $t$ 的需求：$\sum_i D_i$

#### 4.1.3 求解方法与目标函数

使用 NetworkX 库的 `max_flow_min_cost` 算法求解最小费用最大流，该算法基于 successive shortest path 或 cost scaling 方法。

**目标函数对应**：
- 网络流的总费用：$\text{Total Cost} = \sum_{i,j} (-p_i) \cdot y_{ij} = -\sum_{i,j} p_i y_{ij}$
- 最小化总费用等价于最大化总收益：$\max \sum_{i,j} p_i y_{ij} = -\min \text{Total Cost}$

#### 4.1.4 复杂度与最优性保证

**时间复杂度**：
- 网络节点数：$O(n + m)$（实际为 $n + |S| + 2$，其中 $|S| \leq m$）
- 网络边数：$O(n \times m)$（最坏情况每个楼栋都与每个区域相连）
- **总体时间复杂度**：$O((n+m)^2 \times \log(n+m) \times C)$，其中 $C = \max\{D_i, U_j\}$ 是最大容量（多项式时间）

**空间复杂度**：

- 存储网络图：$O(n \times m)$（边的数量）
- 存储流结果：$O(n \times m)$
- **总体空间复杂度**：$O(n \times m)$

**最优性保证**：最小费用最大流算法保证找到最优解（给定 $z$ 和 $x$ 下的最优 $y$），这使得所有使用该方法的求解器都能在给定选址下获得最优的用户分配，确保了算法比较的公平性。

---

### 4.2 暴力枚举（Brute-force）

#### 4.2.1 算法思路  
1. **外层枚举**：枚举所有 $2^m$ 种建设方案 $z \in \{0,1\}^m$
2. **子问题求解**：对每种方案 $z$：
   - 设置充电桩数量：$x_j = U_j \cdot z_j$（直接装满）
   - 使用**最小费用最大流算法**（见4.1节）精确求解最优的用户分配 $y$
   - 计算目标函数值：$\sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$
3. **选择最优解**：记录使目标值最大的 $(z,x,y)$
4. 返回全局最优解

#### 4.2.2 复杂度分析

**时间复杂度**：
- 枚举次数：$2^m$
- 单次最小费用最大流：$O((n+m)^2 \times \log(n+m) \times C)$，其中 $C = \max\{D_i, U_j\}$
- **总体时间复杂度**：$O(2^m \times (n+m)^2 \times \log(n+m) \times C)$

**空间复杂度**：
- 存储当前最优解：$O(n \times m)$（用于存储 $y$ 矩阵）
- 最小费用最大流算法：$O(n+m)$ 个节点，$O(n \times m)$ 条边
- **总体空间复杂度**：$O(n \times m)$

**适用规模**：$m \leq 15$ 时算法尚可接受，$m > 20$ 时基本不可行（指数爆炸）

#### 4.2.3 近似比  
暴力枚举给出全局最优解，近似比 $\rho = 1$，无近似误差。

#### 4.2.4 实现细节

- 支持时间限制（`time_limit` 参数），超时后返回当前找到的最优解
- 对于 $m > 15$ 的情况，仅枚举前1000种方案以避免计算时间过长
- 使用 `itertools.product` 高效生成所有 $(0,1)$ 组合  

---

### 4.3 贪心构造（Greedy Construction）

#### 4.3.1 算法思路  

**阶段 A：构造**  
1. 初始化：所有 $z_j=0$，$x_j=0$，$y_{ij}=0$
2. 计算每个候选区域 $j$ 的「性价比」：
   - 潜在收益：$\text{region\_profits}_j = \bar{p}_j \times \min\{\sum_{i:a_{ij}=1} D_i, U_j\}$，其中 $\bar{p}_j$ 是区域 $j$ 覆盖楼栋的平均单位收益
   - 性价比：$\text{score}_j = \frac{\text{region\_profits}_j}{c_j}$
3. 按性价比从高到低排序区域
4. 依次尝试添加每个区域 $j$：
   - 设置 $z_j=1$，$x_j=U_j$
   - 使用**最小费用最大流算法**（见4.1节）计算最优分配 $y$ 和目标函数值
   - 如果目标函数提升，则保留该区域；否则撤销
5. 对最终选中的区域集合，再次使用最小费用最大流算法进行最优分配

**注意**：与传统的贪心分配不同，本实现使用最小费用最大流算法进行用户分配，确保在给定选址下获得最优的用户分配。

#### 4.3.2 复杂度分析

**时间复杂度**：
- 计算性价比：$O(n \times m)$
- 排序：$O(m \log m)$
- 贪心选择：最多 $m$ 次迭代，每次调用最小费用最大流算法
- **总体时间复杂度**：$O(m \times (n+m)^2 \times \log(n+m) \times C)$

**空间复杂度**：

- 存储当前解：$O(n \times m)$
- 最小费用最大流算法：$O(n \times m)$
- **总体空间复杂度**：$O(n \times m)$

#### 4.3.3 近似比分析  
本问题可视为"带基数惩罚的覆盖+背包"混合问题。沿用 Set-Cover 贪心结论，理论上：
- $\rho \leq H_n + 1$，其中 $H_n = 1 + 1/2 + \ldots + 1/n \approx \ln n$ 是第 $n$ 个调和数
- 若所有 $p_i=1$，退化为带惩罚的集合覆盖，$\rho \leq H_n$
- 一般收益异构时，$\rho \leq H_n \cdot (p_{\max}/p_{\min})$

**实际性能**：由于使用了最小费用最大流进行用户分配，实际性能通常优于传统贪心方法，实验显示实际近似比 $\rho \approx 1.1 \sim 1.3$。

#### 4.3.4 优缺点

**优点**：
- 运行速度快，适合大规模问题
- 实现简单，易于理解和调试
- 使用最小费用最大流确保用户分配的最优性

**缺点**：
- 不能保证全局最优（选址策略是贪心的）
- 可能陷入局部最优  

---

### 4.4 基于 MILP 的精确算法

#### 4.4.1 算法思路  
1. 将第二章的数学模型直接建模为混合整数线性规划（MILP）：
   - 决策变量：$z_j \in \{0,1\}$（二进制），$x_j \in \mathbb{Z}_+$（整数），$y_{ij} \in \mathbb{Z}_+$（整数）
   - 目标函数：$\max \sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$
   - 约束条件：覆盖关系、需求约束、容量约束、以及关键约束 $x_j = U_j \cdot z_j$
2. 使用 PuLP 库调用 CBC 求解器（或其他 MILP 求解器）进行分支定界求解
3. 提取并返回最优解

**注意**：MILP方法直接在模型中优化所有变量，不需要显式调用最小费用最大流算法，但约束 $x_j = U_j \cdot z_j$ 确保了与统一策略的一致性。

#### 4.4.2 复杂度分析

**时间复杂度**：
- 变量数：$m$（$z$）+ $m$（$x$）+ $n \times m$（$y$）= $O(n \times m)$
- 约束数：$O(n \times m)$（覆盖关系）+ $n$（需求）+ $m$（容量）+ $m$（容量上限）= $O(n \times m)$
- 分支定界最坏情况节点数：$O(2^m)$（考虑 $z$ 变量的分支）
- 单节点 LP 松弛：$O((n \times m)^{3.5})$（内点法 worst-case）
- **总体时间复杂度**：指数级，最坏情况 $O(2^m \times (n \times m)^{3.5})$，实际中由于剪枝和预处理通常远小于此

**空间复杂度**：

- 存储 MILP 模型：$O(n \times m)$（约束矩阵）
- 分支定界树：最坏情况 $O(2^m)$ 个节点
- **总体空间复杂度**：$O(n \times m + 2^m)$，实际中由于剪枝通常远小于 $2^m$

**适用规模**：中等规模问题（$m \leq 30$，$n \leq 50$），具体取决于求解器性能

#### 4.4.3 近似比  
MILP 求解器返回最优解时，近似比 $\rho = 1$（全局最优）。若因时间限制提前停止，则给出当前最好的可行解和最优界（gap）。

#### 4.4.4 实现细节

- 使用 PuLP 库进行建模，底层调用 CBC 求解器（开源）
- 支持切换到其他求解器（如 Gurobi、CPLEX）以获得更好的性能
- 所有变量均为整数类型（$x$ 和 $y$ 不使用连续松弛）
- 关键约束 $x_j = U_j \cdot z_j$ 确保选址后充电桩直接装满  

---

### 4.5 遗传算法（Genetic Algorithm, GA）

#### 4.5.1 编码  
- **染色体表示**：二进制串 $\text{ch} \in \{0,1\}^m$，直接表示建设决策 $z$
- **解码过程**：对于给定的染色体 $z$：
  1. 设置充电桩数量：$x_j = U_j \cdot z_j$
  2. 使用**最小费用最大流算法**（见4.1节）精确求解最优的用户分配 $y$
  3. 计算目标函数值：$\sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$

#### 4.5.2 适应度  
适应度函数直接使用目标函数值：
$$\text{fitness}(\text{ch}) = \sum_i \sum_j p_i y_{ij} - \sum_j c_j z_j$$

**注意**：由于使用最小费用最大流算法进行解码，每个个体都能得到给定 $z$ 下的最优 $y$，因此适应度计算是精确的。

#### 4.5.3 遗传算子  
- **初始化**：随机生成初始种群，每个个体以概率 0.3 为 1（偏向选择较少的区域）
- **选择**：轮盘赌选择（适应度比例选择），适应度高的个体被选中概率大
- **交叉**：单点交叉，交叉率 $p_c = 0.8$
- **变异**：位翻转，变异率 $p_m = 0.1$（通常设为 $1/m$）
- **精英保留**：每代保留最优的 10% 个体直接进入下一代

#### 4.5.4 参数与停止条件  
- 种群规模 $N = 50$（默认）
- 最大代数 $G = 100$（默认）
- **早停机制**：如果连续 `early_stop_patience = 20` 代没有改进，提前终止
- 其他参数：交叉率 0.8，变异率 0.1，精英比例 0.1

#### 4.5.5 复杂度分析

**时间复杂度**：
- 初始化：$O(N \times m)$
- 每代评估适应度：$N$ 次解码，每次调用最小费用最大流算法
- 选择、交叉、变异：$O(N \times m)$
- **总体时间复杂度**：$O(G \times N \times (n+m)^2 \times \log(n+m) \times C)$

**空间复杂度**：
- 存储种群：$O(N \times m)$
- 最小费用最大流算法：$O(n \times m)$
- **总体空间复杂度**：$O(N \times m + n \times m)$

#### 4.5.6 近似比与性能  
遗传算法作为元启发式算法，**无理论保证**，但在实践中表现良好：

- **与暴力枚举相比**：在 $m \leq 20$ 的问题上，通常能找到最优解或非常接近最优解（gap $\leq 1\%$）
- **与贪心算法相比**：平均提升 3~8%，特别是在大规模问题上优势明显
- **收敛性**：早停机制确保算法不会过度运行，通常 20-50 代即可收敛

#### 4.5.7 优缺点

**优点**：
- 可以跳出局部最优，适合大规模问题
- 使用最小费用最大流确保每种编码都能得到最优的用户分配
- 早停机制提高效率
- 参数可调，适应性强

**缺点**：
- 不能保证全局最优
- 参数需要调优
- 可能需要较多迭代次数  

---

### 4.6 算法总结与比较

| 算法 | 最优性保证 | 适用规模 | 时间复杂度 | 空间复杂度 | 主要优点 | 主要缺点 |
|------|-----------|----------|-----------|-----------|----------|----------|
| 暴力枚举 | ✓ 全局最优 | $m \leq 15$ | $O(2^m \times \text{MCF})$ | $O(n \times m)$ | 基准算法，结果可靠 | 指数爆炸，仅适用于小规模 |
| 贪心算法 | ✗ 理论 $H_n$ 近似 | 任意规模 | $O(m \times \text{MCF})$ | $O(n \times m)$ | 极速、易实现、使用最小费用最大流 | 可能陷入局部最优 |
| MILP | ✓ 全局最优 | 中等规模 ($m \leq 30$) | 指数级（分支定界） | $O(n \times m + 2^m)$ | 保证最优性，适用于中等规模 | 大规模问题求解时间过长 |
| 遗传算法 | ✗ 元启发式 | 大规模 ($m \leq 500$) | $O(G \times N \times \text{MCF})$ | $O(N \times m + n \times m)$ | 易并行、使用最小费用最大流、早停机制 | 参数敏感，无理论保证 |

其中：
- $\text{MCF} = O((n+m)^2 \times \log(n+m) \times C)$ 是最小费用最大流的复杂度（多项式时间）
- $G$ 是遗传算法的代数，$N$ 是种群大小
- $C = \max\{D_i, U_j\}$ 是最大容量

**关键设计特点**：
- 所有算法都采用统一的策略（见4.1节）：选址后充电桩直接装满，然后使用最小费用最大流算法最优分配用户
- 这确保了所有方法都能在给定选址下获得最优的用户分配，算法比较更加公平
- 最小费用最大流算法提供了多项式时间的精确求解方法，相比传统的 LP 或贪心分配更加高效和准确

---

## 5. 实验数据结果分析

本节基于实际测试数据（50个问题实例，涵盖5种不同规模：$n \in \{10,15,20,25,30\}$，$m \in \{5,8,10,12,15\}$）对四种算法的性能进行分析。

### 5.1 实验结果统计

下表展示了不同问题规模下各方法的**达到最优解的次数**（共10个实例）和**平均运行时间**：

| 问题规模 | 方法 | 达到最优解次数 | 最优解概率 | 平均运行时间 |
|---------|------|--------------|-----------|-------------|
| $n=10, m=5$ | 贪心算法 | 9/10 | 90% | 15.8ms |
| | MILP求解器 | 10/10 | **100%** | 12.8ms |
| | 暴力枚举 | 10/10 | **100%** | 32.6ms |
| | 遗传算法 | 10/10 | **100%** | 1.221s |
| $n=15, m=8$ | 贪心算法 | 7/10 | 70% | 14.2ms |
| | MILP求解器 | 10/10 | **100%** | 21.0ms |
| | 暴力枚举 | 10/10 | **100%** | 387.0ms |
| | 遗传算法 | 10/10 | **100%** | 2.263s |
| $n=20, m=10$ | 贪心算法 | 7/10 | 70% | 24.0ms |
| | MILP求解器 | 10/10 | **100%** | 45.9ms |
| | 暴力枚举 | 10/10 | **100%** | 2.112s |
| | 遗传算法 | 10/10 | **100%** | 3.452s |
| $n=25, m=12$ | 贪心算法 | 7/10 | 70% | 37.9ms |
| | MILP求解器 | 10/10 | **100%** | 45.8ms |
| | 暴力枚举 | 10/10 | **100%** | 11.145s |
| | 遗传算法 | 10/10 | **100%** | 5.798s |
| $n=30, m=15$ | 贪心算法 | 7/10 | 70% | 61.4ms |
| | MILP求解器 | 10/10 | **100%** | 92.2ms |
| | 暴力枚举 | 0/10 | **0%** | 60.0s (超时) |
| | 遗传算法 | 8/10 | 80% | 8.284s |

### 5.2 结果分析

**1. 最优解质量**

- **MILP求解器**在所有规模下均达到100%最优解概率，验证了其作为精确算法的可靠性
- **暴力枚举**在$m \leq 12$时表现完美（100%），但$m=15$时因指数爆炸无法在时间限制内完成
- **遗传算法**在中小规模（$m \leq 12$）达到100%，但在$m=15$时降至80%
- **贪心算法**最优解概率稳定在70-90%，在所有规模下都存在约1/4的实例无法达到最优

**2. 运行时间性能**

- **贪心算法**在所有规模下均为最快（15-61ms），时间随规模增长缓慢，适合实时决策
- **MILP求解器**在中小规模下非常快（12-46ms），在$m=15$时平均92ms（个别实例可能更长）
- **暴力枚举**时间随$m$指数增长：$m=5$时32ms，$m=12$时已超过11秒，$m=15$时达到时间限制
- **遗传算法**运行时间较长（秒级），但增长相对稳定，适合大规模问题

**3. 各方法特点**

| 方法 | 主要优点 | 主要缺点 | 适用场景 |
|------|---------|---------|---------|
| **贪心算法** | 速度最快（毫秒级），实现简单 | 解质量有限（70-90%最优解概率） | 实时决策、大规模初步筛选 |
| **MILP求解器** | 保证最优解（100%），中小规模下速度快 | 大规模时可能时间较长，依赖求解器 | 中等规模问题的精确求解 |
| **暴力枚举** | 小规模下保证最优，结果可靠 | 指数复杂度，$m > 12$时不可行 | 小规模问题（$m \leq 12$）、算法验证 |
| **遗传算法** | 解质量高（80-100%），可扩展性好 | 运行时间较长（秒级），无理论保证 | 大规模问题的近似最优求解 |

### 5.3 算法选择建议

- **$m \leq 10$**：优先使用**MILP求解器**（保证最优且速度快）
- **$10 < m \leq 15$**：优先使用**MILP求解器**，若时间受限可考虑**遗传算法**或**贪心算法**
- **$m > 15$**：优先使用**遗传算法**（解质量高），若需要快速响应则使用**贪心算法**
- **实时决策场景**：使用**贪心算法**（速度最快）
- **必须保证最优解**：只能使用**MILP求解器**（唯一在所有规模下保证100%最优解的方法）